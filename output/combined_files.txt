# File: .\dump_py.py

import os

def dump_python_files(directory, output_file):
    # Ensure the output directory exists
    os.makedirs(os.path.dirname(output_file), exist_ok=True)

    # Delete the output file if it already exists
    if os.path.exists(output_file):
        os.remove(output_file)

    # Open the output file in write mode
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Walk through the directory
        for root, _, files in os.walk(directory):
            # Skip the 'venv' directory
            if 'venv' in root.split(os.sep):
                continue

            for file in files:
                file_path = os.path.join(root, file)
                
                # Ignore Python files in the output directory itself
                if file.endswith('.py') and not file_path.startswith(os.path.dirname(output_file)):
                    # Write the file name as a header
                    outfile.write(f"# File: {file_path}\n\n")
                    # Read and write the content of the file
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                    outfile.write("\n\n")  # Add some space between files

# Specify the directory containing your Python files and the output file
project_directory = '.'  # Current directory
output_directory = os.path.join(os.getcwd(), 'output')
output_file = os.path.join(output_directory, 'combined_files.txt')

# Combine the files
dump_python_files(project_directory, output_file)
print(f"All Python files have been combined into {output_file}")


# File: .\src\category_parser.py

import logging
from config import BASE_URL

class CategoryParser:
    def __init__(self, booking_url, page):
        if not booking_url.startswith("http"):
            booking_url = BASE_URL + booking_url

        self.booking_url = booking_url
        self.page = page
        self.categories = []

        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)

    def fetch_categories(self):
        self.logger.info(f"Navigating to booking page: {self.booking_url}")
        self.page.goto(self.booking_url, timeout=60000)
        self.logger.info(f"Loaded booking page: {self.booking_url}")

        try:
            self.page.wait_for_selector("[data-testid='category-card']", timeout=10000)
        except Exception as e:
            self.logger.warning(f"No category cards found: {e}")
            return []

        category_elements = self.page.locator("[data-testid='category-card']")
        category_count = category_elements.count()
        self.logger.info(f"Found {category_count} cabin categories.")

        for i in range(category_count):
            category = category_elements.nth(i)

            # Extract attributes using refined selectors
            deck_locator = category.locator("span").filter(has_text="Deck")
            category_name_locator = category.locator("h3")

            # Find the container holding the pax icons and count the number of <svg> icons inside
            pax_icons = category.locator("[class*='pax-icons_'] svg")

            # Find the span containing the cabin type, avoiding buttons
            cabin_type_locator = pax_icons.nth(pax_icons.count() - 1).locator("+ span")

            price_locator = category.locator("h2")

            deck = deck_locator.text_content().strip() if deck_locator.count() > 0 else "Unknown"
            category_name = category_name_locator.text_content().strip() if category_name_locator.count() > 0 else "Unknown"
            occupancy = f"{pax_icons.count()} Person(s)" if pax_icons.count() > 0 else "Unknown"
            cabin_type = cabin_type_locator.text_content().strip() if cabin_type_locator.count() > 0 else "Unknown"
            price = price_locator.text_content().strip() if price_locator.count() > 0 else "Unknown"

            # Detect availability
            see_available_button = category.locator("button").filter(has_text="See available cabins")
            join_waitlist_button = category.locator("button").filter(has_text="Join Waitlist")

            if see_available_button.count() > 0:
                category_status = "Available"
            elif join_waitlist_button.count() > 0:
                category_status = "Waitlist"
            else:
                category_status = "Unknown"

            is_available = category_status == "Available"

            # Log only if available
            if is_available:
                self.logger.info(f"{category_name} - {deck}, {occupancy}, {cabin_type}, {price}, Status: {category_status}")

            self.categories.append({
                "category_name": category_name,
                "deck": deck,
                "occupancy": occupancy,
                "cabin_type": cabin_type,
                "price": price,
                "status": category_status,
                "available": is_available
            })

        return self.categories


# File: .\src\config.py

import logging
from datetime import datetime

# Base URL constants
BASE_URL = "https://www.expeditions.com"

# Default date range for testing
DEFAULT_START_DATE = "2025-05-13"
DEFAULT_END_DATE = "2025-05-29"

# Function to convert date to timestamp
def date_to_timestamp(date_str):
    return int(datetime.strptime(date_str, "%Y-%m-%d").timestamp())

# Allow manual date input, fallback to defaults
START_DATE = input(f"Enter start date (YYYY-MM-DD) [default: {DEFAULT_START_DATE}]: ") or DEFAULT_START_DATE
END_DATE = input(f"Enter end date (YYYY-MM-DD) [default: {DEFAULT_END_DATE}]: ") or DEFAULT_END_DATE

START_TIMESTAMP = date_to_timestamp(START_DATE)
END_TIMESTAMP = date_to_timestamp(END_DATE)

# Construct departures URL
DEPARTURES_URL = f"https://www.expeditions.com/book?dateRange={START_TIMESTAMP}%253A{END_TIMESTAMP}"

# Logging configuration
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


# File: .\src\departure_parser.py

import logging

def fetch_departures(page, trip):
    departures = []
    latest_year = None  # Reset latest_year at the start of each trip's departures
    
    try:
        show_departures_button = trip.locator("button", has_text="See departure dates")
        if show_departures_button.count() > 0:
            show_departures_button.first.click()
            page.wait_for_timeout(200)
            
            departure_container_locator = trip.locator("[class^='hits_departureHitsContainer__']")
            if departure_container_locator.count() == 0:
                return departures
            
            elements = departure_container_locator.locator("li")
            element_count = elements.count()
            
            if element_count == 0:
                logging.info("No visible departures found for this trip. Skipping.")
                return departures
            
            for i in range(element_count):
                departure = elements.nth(i)
                
                year_locator = departure.locator("[data-testid='departure-hit-year']")
                date_range_locator = departure.locator("p[class*='drDbhx']")
                ship_name_locator = departure.locator("i")
                booking_url_locator = departure.locator("a")
                land_expedition_locator = departure.locator("div[data-land-expedition='true']")
                
                # If the year span is present, update latest_year
                if year_locator.count() > 0:
                    latest_year = year_locator.text_content().strip()
                    logging.info(f"Found year line item: {latest_year}")
                
                missing_fields = []
                if latest_year is None:
                    missing_fields.append("year")
                if date_range_locator.count() < 2:
                    missing_fields.append("date range")
                if booking_url_locator.count() == 0:
                    missing_fields.append("booking URL")
                
                if missing_fields:
                    logging.warning(f"Skipping departure {i} due to missing fields: {', '.join(missing_fields)}")
                    continue
                
                # Extract details
                date_range = date_range_locator.all_text_contents()
                ship_name = "Land Expedition" if land_expedition_locator.count() > 0 else ship_name_locator.text_content().strip()
                booking_url = booking_url_locator.get_attribute("href")
                
                # Apply latest_year to start and end dates
                start_date = f"{latest_year} {date_range[0].strip()}"
                end_date = f"{latest_year} {date_range[1].strip()}"
                
                logging.info(f"Found departure: {start_date} to {end_date}, Ship: {ship_name}")
                
                departures.append({
                    "start_date": start_date,
                    "end_date": end_date,
                    "ship": ship_name,
                    "booking_url": booking_url
                })
    except Exception as e:
        logging.error(f"Error fetching departures: {e}")

    return departures


# File: .\src\main.py

# File: ./src/main.py

import logging
from trip_parser import TripParser

def main():
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    
    parser = TripParser()
    trips = parser.fetch_trips(limit=2)
    
    for trip in trips:
        print(trip)

if __name__ == "__main__":
    main()


# File: .\src\trip_parser.py

import logging
from category_parser import CategoryParser
from departure_parser import fetch_departures
from config import BASE_URL, DEPARTURES_URL
from playwright.sync_api import sync_playwright

class TripParser:
    def fetch_trips(self, limit=2):
        trips = []

        with sync_playwright() as p:
            browser = p.chromium.launch(headless=True)
            page = browser.new_page()
            page.goto(DEPARTURES_URL, timeout=60000)
            logging.info("Loaded departures page.")
            
            page.wait_for_selector("[class^='hit_container__']", timeout=10000)
            trip_elements = page.locator("[class^='hit_container__']")
            trip_count = trip_elements.count()
            logging.info(f"Found {trip_count} trips.")
            
            for i in range(trip_count):
                trip = trip_elements.nth(i)
                trip_name_locator = trip.locator("[class^='card_name__']")
                if trip_name_locator.count() == 0:
                    continue
                
                trip_name = trip_name_locator.text_content().strip()
                trip_url = trip_name_locator.get_attribute("href")
                full_trip_url = f"{BASE_URL}{trip_url}" if trip_url else None
                logging.info(f"{trip_name} - {full_trip_url}")
                
                departures = fetch_departures(page, trip)
                
                trips.append({
                    "trip_name": trip_name,
                    "url": full_trip_url,
                    "departures": departures
                })
            
            # Second pass: Process bookings for trips with departures
            for trip in trips:
                for departure in trip["departures"]:
                    booking_url = departure["booking_url"]
                    if booking_url:
                        logging.info(f"Fetching categories for booking: {booking_url}")
                        category_parser = CategoryParser(booking_url, page)
                        departure["categories"] = category_parser.fetch_categories()
            
            browser.close()
        
        return trips

# File: .\src\__init__.py



# File: .\tests\conftests.py

import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "../src")))


# File: .\tests\test_trip_parser.py

import unittest
from src.scraper import TripParser

class TestTripParser(unittest.TestCase):

    def setUp(self):
        """Set up sample JSON response before each test."""
        self.sample_json = {
            "trip_name": "The Panama Canal, Pearl Islands and Darién Jungle",
            "destination": "Central America > South America > New and Noteworthy",
            "duration": "8 days"
        }

    def test_parse_trip_attributes(self):
        """Test that the parser correctly extracts basic trip details."""
        parser = TripParser()
        result = parser.parse_trip_list(self.sample_json)  # This method will process the JSON
        expected = self.sample_json  # Expected result should match the sample JSON
        self.assertEqual(result, expected)

if __name__ == "__main__":
    unittest.main()


# File: .\tests\__init__.py



