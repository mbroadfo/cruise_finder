# File: .\dump_py.py

import os

def dump_python_files(directory, output_file):
    # Ensure the output directory exists
    os.makedirs(os.path.dirname(output_file), exist_ok=True)

    # Delete the output file if it already exists
    if os.path.exists(output_file):
        os.remove(output_file)

    # Open the output file in write mode
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Walk through the directory
        for root, _, files in os.walk(directory):
            # Skip the 'venv' directory
            if 'venv' in root.split(os.sep):
                continue

            for file in files:
                file_path = os.path.join(root, file)
                
                # Ignore Python files in the output directory itself
                if file.endswith('.py') and not file_path.startswith(os.path.dirname(output_file)):
                    # Write the file name as a header
                    outfile.write(f"# File: {file_path}\n\n")
                    # Read and write the content of the file
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                    outfile.write("\n\n")  # Add some space between files

# Specify the directory containing your Python files and the output file
project_directory = '.'  # Current directory
output_directory = os.path.join(os.getcwd(), 'output')
output_file = os.path.join(output_directory, 'combined_files.txt')

# Combine the files
dump_python_files(project_directory, output_file)
print(f"All Python files have been combined into {output_file}")


# File: .\src\category_parser.py

import logging
from playwright.sync_api import sync_playwright

class CategoryParser:
    def __init__(self, booking_url):
        self.booking_url = booking_url
        self.categories = []
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)
    
    def fetch_categories(self):
        with sync_playwright() as p:
            browser = p.chromium.launch(headless=True)
            page = browser.new_page()
            page.goto(self.booking_url, timeout=60000)
            self.logger.info(f"Loaded booking page: {self.booking_url}")
            
            page.wait_for_selector("[data-testid='category-card']", timeout=10000)
            category_elements = page.locator("[data-testid='category-card']")
            category_count = category_elements.count()
            self.logger.info(f"Found {category_count} cabin categories.")
            
            for i in range(category_count):
                category = category_elements.nth(i)
                
                category_name_locator = category.locator("h3")
                category_status_locator = category.locator("button")
                
                if category_name_locator.count() == 0:
                    continue
                
                category_name = category_name_locator.text_content().strip()
                category_status = category_status_locator.text_content().strip() if category_status_locator.count() > 0 else "Unknown"
                
                is_available = "See available cabins" in category_status
                
                self.categories.append({
                    "category_name": category_name,
                    "status": category_status,
                    "available": is_available
                })
            
            browser.close()
        
        return self.categories
    
if __name__ == "__main__":
    test_url = "https://www.expeditions.com/book/some-booking-url"  # Replace with an actual booking URL
    parser = CategoryParser(test_url)
    categories = parser.fetch_categories()
    for category in categories:
        print(category)


# File: .\src\config.py

import logging
from datetime import datetime

# Base URL constants
BASE_URL = "https://www.expeditions.com"

# Default date range for testing
DEFAULT_START_DATE = "2025-05-13"
DEFAULT_END_DATE = "2025-05-29"

# Function to convert date to timestamp
def date_to_timestamp(date_str):
    return int(datetime.strptime(date_str, "%Y-%m-%d").timestamp())

# Allow manual date input, fallback to defaults
START_DATE = input(f"Enter start date (YYYY-MM-DD) [default: {DEFAULT_START_DATE}]: ") or DEFAULT_START_DATE
END_DATE = input(f"Enter end date (YYYY-MM-DD) [default: {DEFAULT_END_DATE}]: ") or DEFAULT_END_DATE

START_TIMESTAMP = date_to_timestamp(START_DATE)
END_TIMESTAMP = date_to_timestamp(END_DATE)

# Construct departures URL
DEPARTURES_URL = f"https://www.expeditions.com/book?dateRange={START_TIMESTAMP}%253A{END_TIMESTAMP}"

# Logging configuration
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


# File: .\src\departure_parser.py

from config import BASE_URL, logger

def fetch_departures(page, trip):
    departures = []
    latest_year = None  # Reset latest_year at the start of each trip's departures
    
    try:
        show_departures_button = trip.locator("button", has_text="See departure dates")
        if show_departures_button.count() > 0:
            show_departures_button.first.click()
            page.wait_for_timeout(200)
            
            departure_container_locator = trip.locator("[class^='hits_departureHitsContainer__']")
            if departure_container_locator.count() == 0:
                return departures
            
            elements = departure_container_locator.locator("li")
            element_count = elements.count()
            
            if element_count == 0:
                logger.info("No visible departures found for this trip. Skipping.")
                return departures
            
            for i in range(element_count):
                departure = elements.nth(i)
                
                year_locator = departure.locator("[data-testid='departure-hit-year']")
                date_range_locator = departure.locator("p[class*='drDbhx']")
                ship_name_locator = departure.locator("i")
                booking_url_locator = departure.locator("a")
                land_expedition_locator = departure.locator("div[data-land-expedition='true']")
                
                # If the year span is present, update latest_year
                if year_locator.count() > 0:
                    latest_year = year_locator.text_content().strip()
                    logger.info(f"Found year line item: {latest_year}")
                
                missing_fields = []
                if latest_year is None:
                    missing_fields.append("year")
                if date_range_locator.count() < 2:
                    missing_fields.append("date range")
                if booking_url_locator.count() == 0:
                    missing_fields.append("booking URL")
                
                if missing_fields:
                    logger.warning(f"Skipping departure {i} due to missing fields: {', '.join(missing_fields)}")
                    continue
                
                # Extract details
                date_range = date_range_locator.all_text_contents()
                ship_name = "Land Expedition" if land_expedition_locator.count() > 0 else ship_name_locator.text_content().strip()
                booking_url = booking_url_locator.get_attribute("href")
                
                # Apply latest_year to start and end dates
                start_date = f"{latest_year} {date_range[0].strip()}"
                end_date = f"{latest_year} {date_range[1].strip()}"
                
                logger.info(f"Found departure: {start_date} to {end_date}, Ship: {ship_name}")
                
                departures.append({
                    "start_date": start_date,
                    "end_date": end_date,
                    "ship": ship_name,
                    "booking_url": f"{BASE_URL}{booking_url}"
                })
    except Exception as e:
        logger.error(f"Error fetching departures: {e}")

    return departures


# File: .\src\trip_parser.py

from playwright.sync_api import sync_playwright
from config import BASE_URL, DEPARTURES_URL, logger
from departure_parser import fetch_departures

class TripParser:
    def fetch_trips(self, limit=2):
        trips = []

        with sync_playwright() as p:
            browser = p.chromium.launch(headless=True)
            page = browser.new_page()
            page.goto(DEPARTURES_URL, timeout=60000)
            logger.info("Loaded departures page.")
            
            page.wait_for_selector("[class^='hit_container__']", timeout=10000)
            trip_elements = page.locator("[class^='hit_container__']")
            trip_count = trip_elements.count()
            logger.info(f"Found {trip_count} trips.")
            
            for i in range(trip_count):
                trip = trip_elements.nth(i)
                trip_name_locator = trip.locator("[class^='card_name__']")
                if trip_name_locator.count() == 0:
                    continue
                
                trip_name = trip_name_locator.text_content().strip()
                trip_url = trip_name_locator.get_attribute("href")
                full_trip_url = f"{BASE_URL}{trip_url}" if trip_url else None
                logger.info(f"{trip_name} - {full_trip_url}")
                
                departures = fetch_departures(page, trip)
                if departures:
                    trips.append({
                        "trip_name": trip_name,
                        "url": full_trip_url,
                        "departures": departures
                    })
            browser.close()

        return trips

if __name__ == "__main__":
    parser = TripParser()
    trips = parser.fetch_trips(limit=2)
    for trip in trips:
        print(trip)


# File: .\src\__init__.py



# File: .\tests\conftests.py

import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "../src")))


# File: .\tests\test_trip_parser.py

import unittest
from src.scraper import TripParser

class TestTripParser(unittest.TestCase):

    def setUp(self):
        """Set up sample JSON response before each test."""
        self.sample_json = {
            "trip_name": "The Panama Canal, Pearl Islands and Darién Jungle",
            "destination": "Central America > South America > New and Noteworthy",
            "duration": "8 days"
        }

    def test_parse_trip_attributes(self):
        """Test that the parser correctly extracts basic trip details."""
        parser = TripParser()
        result = parser.parse_trip_list(self.sample_json)  # This method will process the JSON
        expected = self.sample_json  # Expected result should match the sample JSON
        self.assertEqual(result, expected)

if __name__ == "__main__":
    unittest.main()


# File: .\tests\__init__.py



